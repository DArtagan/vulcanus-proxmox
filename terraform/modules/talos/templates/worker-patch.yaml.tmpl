machine:
  install:
    disk: /dev/vda
  network:
    hostname: ${hostname}
  disks:
    - device: /dev/vdb
      partitions:
        - mountpoint: /var/openebs

  udev:
    #rules:
    #  - KERNEL=="sr0", ENV{UDISKS_IGNORE}=1
    #  - KERNEL=="sr0", SYMLINK-="cdrom"
  files:
    ## Clean
    #- path: /lib/udev/rules.d/90-iocost.rules
    #- path: /lib/udev/rules.d/60-block.rules
    #- path: /lib/udev/rules.d/66-azure.rules
    #
    #- path: /usr/local/lib/modprobe.d/cdrom.conf
    #  permissions: 0o644
    #  op: create
    #  content: |
    #    install cdrom /bin/true
    #- path: /lib/udev/rules.d/60-cdrom_id.rules
    #  permissions: 0o644
    #  op: create
    #  content: |
    #    ACTION=="remove", GOTO="cdrom_end"
    #    SUBSYSTEM!="block", GOTO="cdrom_end"
    #    KERNEL!="sr[0-9]*|vdisk*|xvd*", GOTO="cdrom_end"
    #    ENV{DEVTYPE}!="disk", GOTO="cdrom_end"
    #    LABEL="cdrom_end"
    - path: /lib/udev/rules.d/60-persistent-storage.rules
      permissions: 0o644
      op: overwrite
      content: |
        # persistent storage links: /dev/disk/{by-id,by-uuid,by-label,by-path}
        # scheme based on "Linux persistent device names", 2004, Hannes Reinecke <hare@suse.de>

        ACTION=="remove", GOTO="persistent_storage_end"
        ENV{UDEV_DISABLE_PERSISTENT_STORAGE_RULES_FLAG}=="1", GOTO="persistent_storage_end"

        SUBSYSTEM!="block|ubi", GOTO="persistent_storage_end"
        KERNEL!="loop*|mmcblk*[0-9]|msblk*[0-9]|mspblk*[0-9]|nvme*|sd*|sr*|vd*|xvd*|bcache*|cciss*|dasd*|ubd*|ubi*|scm*|pmem*|nbd*|zd*|rbd*|zram*|ublkb*", GOTO="persistent_storage_end"

        # ignore partitions that span the entire disk
        TEST=="whole_disk", GOTO="persistent_storage_end"

        # For partitions import parent disk ID_* information, except ID_FS_*.
        #
        # This is particularly important on media where a filesystem superblock and
        # partition table are found on the same level, e.g. common Linux distro ISO
        # installation media.
        #
        # In the case where a partition device points to the same filesystem that
        # was detected on the parent disk, the ID_FS_* information is already
        # present on the partition devices as well as the parent, so no need to
        # propagate it. In the case where the partition device points to a different
        # filesystem, merging the parent ID_FS_ properties would lead to
        # inconsistencies, so we avoid doing so.
        ENV{DEVTYPE}=="partition", \
          IMPORT{parent}="ID_[!F]*", IMPORT{parent}="ID_", \
          IMPORT{parent}="ID_F[!S]*", IMPORT{parent}="ID_F", \
          IMPORT{parent}="ID_FS[!_]*", IMPORT{parent}="ID_FS"

        ENV{DEVTYPE}=="partition", ENV{.PART_SUFFIX}="-part%n"
        ENV{DEVTYPE}!="partition", ENV{.PART_SUFFIX}=""

        # virtio-blk
        KERNEL=="vd*", ATTRS{serial}=="?*", ENV{ID_SERIAL}="$attr{serial}", SYMLINK+="disk/by-id/virtio-$env{ID_SERIAL}$env{.PART_SUFFIX}"

        # by-path
        ENV{DEVTYPE}=="disk", DEVPATH!="*/virtual/*", IMPORT{builtin}="path_id"
        ENV{DEVTYPE}=="disk", SUBSYSTEMS=="nvme-subsystem", IMPORT{builtin}="path_id"
        KERNEL=="mmcblk[0-9]boot[0-9]", ENV{DEVTYPE}=="disk", ENV{ID_PATH}=="?*",                   SYMLINK+="disk/by-path/$env{ID_PATH}-boot%n"
        KERNEL=="mmcblk[0-9]boot[0-9]", ENV{DEVTYPE}=="disk", ENV{ID_PATH_WITH_USB_REVISION}=="?*", SYMLINK+="disk/by-path/$env{ID_PATH_WITH_USB_REVISION}-boot%n"
        KERNEL!="mmcblk[0-9]boot[0-9]",                       ENV{ID_PATH}=="?*",                   SYMLINK+="disk/by-path/$env{ID_PATH}$env{.PART_SUFFIX}"
        KERNEL!="mmcblk[0-9]boot[0-9]",                       ENV{ID_PATH_ATA_COMPAT}=="?*",        SYMLINK+="disk/by-path/$env{ID_PATH_ATA_COMPAT}$env{.PART_SUFFIX}"
        KERNEL!="mmcblk[0-9]boot[0-9]",                       ENV{ID_PATH_WITH_USB_REVISION}=="?*", SYMLINK+="disk/by-path/$env{ID_PATH_WITH_USB_REVISION}$env{.PART_SUFFIX}"

        # legacy virtio-pci by-path links (deprecated)
        KERNEL=="vd*", ENV{ID_PATH}=="pci-*",                   SYMLINK+="disk/by-path/virtio-$env{ID_PATH}$env{.PART_SUFFIX}"
        KERNEL=="vd*", ENV{ID_PATH_WITH_USB_REVISION}=="pci-*", SYMLINK+="disk/by-path/virtio-$env{ID_PATH_WITH_USB_REVISION}$env{.PART_SUFFIX}"

        # by-label/by-uuid links (filesystem metadata)
        ENV{ID_FS_USAGE}=="filesystem|other|crypto", ENV{ID_FS_UUID_ENC}=="?*", SYMLINK+="disk/by-uuid/$env{ID_FS_UUID_ENC}"
        ENV{ID_FS_USAGE}=="filesystem|other|crypto", ENV{ID_FS_LABEL_ENC}=="?*", SYMLINK+="disk/by-label/$env{ID_FS_LABEL_ENC}"

        # by-id (World Wide Name)
        ENV{ID_WWN_WITH_EXTENSION}=="?*", SYMLINK+="disk/by-id/wwn-$env{ID_WWN_WITH_EXTENSION}$env{.PART_SUFFIX}"

        # by-partlabel/by-partuuid links (partition metadata)
        ENV{ID_PART_ENTRY_UUID}=="?*", SYMLINK+="disk/by-partuuid/$env{ID_PART_ENTRY_UUID}"
        ENV{ID_PART_ENTRY_SCHEME}=="gpt", ENV{ID_PART_ENTRY_NAME}=="?*", SYMLINK+="disk/by-partlabel/$env{ID_PART_ENTRY_NAME}"

        # by-path/<path>/by-* links (path + partition/filesystem metadata)
        ENV{ID_PATH}=="", GOTO="persistent_storage_by-path_parts_end"
        ENV{DEVTYPE}!="partition", GOTO="persistent_storage_by-path_parts_end"

        SYMLINK+="disk/by-path/$env{ID_PATH}-part/by-partnum/%n"
        ENV{ID_PART_ENTRY_UUID}=="?*", SYMLINK+="disk/by-path/$env{ID_PATH}-part/by-partuuid/$env{ID_PART_ENTRY_UUID}"
        ENV{ID_PART_ENTRY_SCHEME}=="gpt", ENV{ID_PART_ENTRY_NAME}=="?*", SYMLINK+="disk/by-path/$env{ID_PATH}-part/by-partlabel/$env{ID_PART_ENTRY_NAME}"

        ENV{ID_FS_USAGE}=="filesystem|other|crypto", ENV{ID_FS_UUID_ENC}=="?*", SYMLINK+="disk/by-path/$env{ID_PATH}-part/by-uuid/$env{ID_FS_UUID_ENC}"
        ENV{ID_FS_USAGE}=="filesystem|other|crypto", ENV{ID_FS_LABEL_ENC}=="?*", SYMLINK+="disk/by-path/$env{ID_PATH}-part/by-label/$env{ID_FS_LABEL_ENC}"

        LABEL="persistent_storage_by-path_parts_end"

        # by-diskseq link (if an app is told to open a path like this, they may parse
        # the diskseq number from the path, then issue BLKGETDISKSEQ to verify they really got
        # the right device, to access specific disks in a race-free fashion)
        ENV{DISKSEQ}=="?*", ENV{ID_IGNORE_DISKSEQ}!="1", SYMLINK+="disk/by-diskseq/$env{DISKSEQ}$env{.PART_SUFFIX}"

        # Create symlinks that allow referencing loopback devices by their backing file's inode number
        ENV{ID_LOOP_BACKING_DEVICE}!="", ENV{ID_LOOP_BACKING_INODE}!="", SYMLINK+="disk/by-loop-inode/$env{ID_LOOP_BACKING_DEVICE}-$env{ID_LOOP_BACKING_INODE}$env{.PART_SUFFIX}"

        # Similar, but uses the .lo_file_name field of the loopback device (note that
        # this is basically just a free-form string passed from userspace to the kernel
        # when the device is created, it is not necessarily a file system path like the
        # "loop/backing_file" sysfs attribute, which is always an absolute path)
        ENV{ID_LOOP_BACKING_FILENAME_ENC}!="", SYMLINK+="disk/by-loop-ref/$env{ID_LOOP_BACKING_FILENAME_ENC}$env{.PART_SUFFIX}"

        LABEL="persistent_storage_end"
